#!/usr/bin/python

import serial
import argparse

# qmx-cat by W2TEF begun 1 Nov 2025

# TODO: Note that setting a string to an empty string doesn't change it
# TODO: Check input validity for set?
# TODO: distinguish or combine dump/report

parser = argparse.ArgumentParser(
formatter_class = argparse.RawDescriptionHelpFormatter,
description = """
Send CAT commands to a serial port and receive responses. 
Includes special utilities for the QRP-Labs QMX radios.
""",
epilog = """
Notes: 
- The "dump" command will bypass the "Band config." and "Advanced config!" menus.
 
USE AT YOUR OWN RISK! Changing settings unthoughtfully can damage your radio.
 
This software has no connection to QRP-Labs or its principals, except that I am a grateful user of their products. 
Refer to the "CAT Programming Manual" to understand what's going on here.
 
Copyright Â© 2025  Todd Foster, W2TEF  
License: MIT/X11 License <https://opensource.org/license/MIT>  
This  is free software: you are free to change and redistribute it.  
There is NO WARRANTY, to the extent permitted by law.
""")

parser.add_argument("-p", "--port", 
                    default="/dev/ttyACM0",
                    help="the port connected to the QMX (default=/dev/ttyACM0)") 
command_parser = parser.add_subparsers(dest='command')

get_p = command_parser.add_parser('get', help='PATH: get a menu value')
get_p.add_argument('path')

set_p = command_parser.add_parser('set', help='PATH VALUE: set a menu value')
set_p.add_argument('path')
set_p.add_argument('value')

show_p = command_parser.add_parser('show', help='[PATH]: display (nearly) all settings')
show_p.add_argument('path', default="", nargs='?')
show_p.add_argument('-r', "--recursive",
                   action='store_true',
                   help="recurse through any submenus")

load_p = command_parser.add_parser('load', help="FILE or - for STDIN: set multiple menu values (input format same as report format)")
load_p.add_argument('infile', type=argparse.FileType('r'), default='-')

type_p= command_parser.add_parser('type', help='PATH: get the type of a menu item')
type_p.add_argument('path')

mmq_p = command_parser.add_parser('mm?', help='PATH: query a menu entry')
mmq_p.add_argument('path')

ml_p = command_parser.add_parser('ml', help='PATH: show a menu list')
ml_p.add_argument('list_number')

cat_p = command_parser.add_parser('cat', help='CMD [-n --no_wait for response]: send a cat command (semi-colon optional)')
cat_p.add_argument('cat_command')
cat_p.add_argument('-n', "--no_wait",
                   action='store_true',
                   help="don't wait for a response")

args = parser.parse_args()



# NOTE: Band config is a table; not handled here
# NOTE: Advanced config! I don't want to entrust to an automated tool
MENUS_TO_AVOID = ["Band config.[16]", "System config|Advanced config!"] 

NON_VALUE_TYPES = ["0", "1", "6"]

SUBDIRECTORY_TYPE = 0

DATA_TYPES = { "0":"Sub-menu", "1":"Action", "2":"String", "3":"Number",
               "4":"Byte", "5":"Defined", "6":"Info", "7":"Mask" }

ROOT_PATH = "root - unique string"

SHOW_DIVIDER = "#############"

def cat(qmx, command):
    qmx.write(command.encode("utf-8"))

def cat_with_response(qmx, command):
    cat(qmx, command)
    return qmx.read_until(b';').decode('utf-8').strip()

def strip_menu_response(t):
    # TODO: Verify correct response: MM.*;
    return t[2:-1]

def menu_get(qmx, path):
    return strip_menu_response(cat_with_response(qmx, f"MM{path};"))

def menu_set(qmx, path, value):
    alpha_path = menu_path_to_alpha(qmx, path)
    if (value=="" and alpha_path.startswith("Messages|Message")):
        value=" " # TODO: Ugly hack to clear a string 
    return cat(qmx, f"MM{path}={value};")

def menu_type(qmx, path):
    item = menu_query(qmx, path)
    type = DATA_TYPES[item["typeid"]]
    if type == "Defined":
        type = type + ": " + menu_list(qmx, item["listid"])
    return type

def menu_list(qmx, listRef):
    return strip_menu_response(cat_with_response(qmx, f"ML{listRef};"))

def menu_query(qmx, path):
    response = cat_with_response(qmx, f"MM{path}?;")
    if response == "?;":
        return None
    response = strip_menu_response(response)
    response = response.split("|")
    typeid=response[0]
    listid=response[1]
    descriptor = response[2]
    value = None
    if typeid not in NON_VALUE_TYPES:
        value = menu_get(qmx, path)
    return {"path":path, 
            "typeid":typeid, 
            "listid":listid, 
            "descriptor":descriptor, 
            "value":value}

def menu_path_to_alpha(qmx, path):
    result = []
    path_steps = path.split("|")
    for i in range(len(path_steps)):
        this_path = "|".join(path_steps[0:i+1])
        result.append(menu_query(qmx, this_path)["descriptor"])
    return "|".join(result)

def is_submenu(item):
    return item["typeid"]==f"{SUBDIRECTORY_TYPE}"

def menu_report(qmx, path):
    if path == ROOT_PATH:
        return f"{SHOW_DIVIDER}\n# ROOT MENU\n{SHOW_DIVIDER}";
    item = menu_query(qmx, path)
    alpha_path = menu_path_to_alpha(qmx, path)
    if is_submenu(item):
        return f"# {alpha_path} -- SUBDIRECTORY";
    elif item["typeid"] in NON_VALUE_TYPES:
        return f"# {alpha_path}";
    else:
        return f"{alpha_path}={item["value"]}"

def explore_submenu(qmx, path):
    result=[]
    if len(path) > 0 and path[-1] != "|":
        path = path + "|"
    for i in range(100):
        response = menu_query(qmx, f"{path}{i}")
        if response == None:
            break
        result.append(response)
    return result

def show(qmx, path, recursive):
    # If what is passed initially is a submenu, traverse it
    target = menu_query(qmx, path)
    if target == None and len(path.strip()) > 0:
        return
    items = [ target ]
    if len(path.strip()) == 0:
        print(menu_report(qmx, ROOT_PATH))
        items = explore_submenu(qmx, "")
    elif is_submenu(target):
        items = explore_submenu(qmx, path)

    submenus = []
    for i in items:
        print(menu_report(qmx, i["path"]))
        if is_submenu(i):
            submenus.append(i)

    if recursive:
        for s in submenus:
            if menu_path_to_alpha(qmx, s["path"]) not in MENUS_TO_AVOID:
                print(SHOW_DIVIDER)
                show(qmx, s["path"], recursive)


qmx = serial.Serial(args.port)  # open serial port

if args.command == "cat":
    command = args.cat_command
    # Sugar: bash interprets the semicolon instead of passing it, so make optional
    if command[-1] != ';':
        command = command + ";"
    if args.no_wait:
        cat(qmx, command)
    else:
        print(cat_with_response(qmx, command))
elif args.command == "get":
    print(menu_get(qmx, args.path))
elif args.command == "set":
    menu_set(qmx, args.path, args.value)
elif args.command == "type":
    print(menu_type(qmx, args.path))
elif args.command == "show":
    show(qmx, args.path, args.recursive)
elif args.command == "mm?":
    print(menu_query(qmx, args.path))
elif args.command == "ml":
    print(menu_list(qmx, args.list_number))
elif args.command == "load":
    with args.infile as file:
        for line in file:
            if line[0] == "#":
                continue
            pieces = line.strip().split("=", 1)
            menu_set(qmx, pieces[0], pieces[1])

qmx.close()
